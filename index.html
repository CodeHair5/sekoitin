<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Erlenmeyer-pullo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; cursor: pointer; }
        .info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            font-family: Arial, sans-serif;
            font-size: 16px;
            pointer-events: none;
            text-shadow: 0 0 5px white;
        }
    </style>
</head>
<body>
    <div class="info">Paina nappia käynnistääksesi sekoittajan. Vedä hiirellä pyörittääksesi.</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, flaskFront, flaskBack, liquid, meniscus, stirrer, swirlParticles, bubbleTrail;
        let stirrerPlate, stirrerButton;
        let isStirring = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let liquidMaterial; // To hold reference to the material with the shader

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 15, 5);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(0, 2, 0);
            scene.add(pointLight);

            // Create the objects
            createFlask();
            createLiquidAndEffects();
            createSwirlParticles();
            createBubbleTrail();
            createStirrer();
            createStirrerPlate();

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.target.set(0, 5, 0);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('pointerdown', onMouseClick, false);

            animate();
        }

        function createFlask() {
            const points = [];
            points.push(new THREE.Vector2(0, 0));
            points.push(new THREE.Vector2(6, 0));
            points.push(new THREE.Vector2(6, 0.5));
            points.push(new THREE.Vector2(2, 11.5));
            points.push(new THREE.Vector2(2, 15));
            points.push(new THREE.Vector2(2.5, 15.5));
            points.push(new THREE.Vector2(2.5, 16));
            points.push(new THREE.Vector2(2.2, 16));

            const geometry = new THREE.LatheGeometry(points, 32);
            
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xadd8e6,
                metalness: 0.1,
                roughness: 0.05,
                transmission: 1.0,
                thickness: 0.5,
                ior: 1.5,
                transparent: true,
                opacity: 0.3,
                envMapIntensity: 2,
                side: THREE.DoubleSide,
                depthWrite: false,
                depthTest: false
            });
            flaskFront = new THREE.Mesh(geometry, glassMaterial);
            flaskFront.renderOrder = 5; // FINAL RENDER ORDER
            scene.add(flaskFront);
        }
        
        function createLiquidAndEffects() {
            const liquidHeight = 7.0;
            const liquidRadiusAtTop = 3.4;
            const points = [];
            points.push(new THREE.Vector2(0, 0.2)); 
            points.push(new THREE.Vector2(5.8, 0.2));
            points.push(new THREE.Vector2(liquidRadiusAtTop, liquidHeight));
            points.push(new THREE.Vector2(0, liquidHeight));

            const geometry = new THREE.LatheGeometry(points, 64);

            liquidMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                transmission: 1.0,
                roughness: 0.1,
                metalness: 0.0,
                ior: 1.33,
                thickness: 1.0,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
                depthWrite: false,
                 depthTest: false,
                envMapIntensity: 2
            });
            
            liquidMaterial.onBeforeCompile = (shader) => {
                shader.uniforms.u_time = { value: 0 };
                shader.uniforms.u_strength = { value: 0 };

                shader.vertexShader = 'uniform float u_time;\n' + 'uniform float u_strength;\n' + shader.vertexShader;
                
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    `
                    #include <begin_vertex>
                    
                    if (position.y > ${liquidHeight - 0.01}) {
                        float dist = length(position.xz);
                        float depression = exp(-dist * 1.5) * 1.5 * u_strength;
                        transformed.y -= depression;
                        float wave = sin(dist * 3.0 - u_time * 5.0) * 0.1 * u_strength;
                        transformed.y += wave;
                    }
                    `
                );
                
                liquidMaterial.userData.shader = shader;
            };

            liquid = new THREE.Mesh(geometry, liquidMaterial);
            liquid.renderOrder = 1;
            scene.add(liquid);
            
            const meniscusGeometry = new THREE.TorusGeometry(liquidRadiusAtTop, 0.05, 16, 100);
            const meniscusMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.5,
                depthWrite: false,
                metalness: 0.0,
                roughness: 0.1,
                transmission: 0.5,
                ior: 1.33,
                envMapIntensity: 1
            });
            meniscus = new THREE.Mesh(meniscusGeometry, meniscusMaterial);
            meniscus.position.y = liquidHeight;
            meniscus.rotation.x = Math.PI / 2;
            meniscus.renderOrder = 4;
            scene.add(meniscus);
        }

        function createSwirlParticles() {
            const particleCount = 500;
            const positions = new Float32Array(particleCount * 3);
            const liquidHeight = 7.0;
            const maxRadius = 5.5;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const radius = Math.random() * maxRadius;
                const angle = Math.random() * Math.PI * 2;
                const y = Math.random() * liquidHeight;
                positions[i3] = radius * Math.cos(angle);
                positions[i3 + 1] = y;
                positions[i3 + 2] = radius * Math.sin(angle);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.07,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    depthWrite: false,
                });

            swirlParticles = new THREE.Points(geometry, material);
            swirlParticles.renderOrder = 2; // Render after liquid
            swirlParticles.visible = false;
            scene.add(swirlParticles);
        }

        function createBubbleTrail() {
            const particleCount = 150;
            const positions = new Float32Array(particleCount * 3);
            const data = []; 

            for (let i = 0; i < particleCount; i++) {
                positions.set([0, -100, 0], i * 3);
                data.push({
                    velocity: new THREE.Vector3(),
                    life: 0 
                });
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.userData.data = data; 

            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.08, 
                transparent: true,
                opacity: 0.8,
                blending: THREE.NormalBlending, // CORRECTED
                depthWrite: true,
            });
                bubbleTrail = new THREE.Points(geometry, material);
                bubbleTrail.renderOrder = 3; // Render after swirl particles
                bubbleTrail.visible = false;
                scene.add(bubbleTrail);

            bubbleTrail = new THREE.Points(geometry, material);
            bubbleTrail.renderOrder = 3; // Render after swirl particles
            bubbleTrail.visible = false;
            scene.add(bubbleTrail);
        }

        function createStirrer() {
            const geometry = new THREE.CapsuleGeometry(0.3, 2.5, 4, 16);
            const material = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.1, metalness: 0.2 });
            stirrer = new THREE.Mesh(geometry, material);
            stirrer.rotation.z = Math.PI / 2;
            stirrer.position.y = 0.6;
            scene.add(stirrer);
        }

        function createStirrerPlate() {
            const plateGeometry = new THREE.BoxGeometry(15, 2, 15);
            const plateMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5, metalness: 0.1 });
            stirrerPlate = new THREE.Mesh(plateGeometry, plateMaterial);
            stirrerPlate.position.y = -1.1;
            scene.add(stirrerPlate);

            const buttonGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 32);
            const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            stirrerButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
            stirrerButton.position.set(5, 1.25, 5); 
            stirrerPlate.add(stirrerButton); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([stirrerButton]);
            if (intersects.length > 0) {
                isStirring = !isStirring;
                if (isStirring) {
                    stirrerButton.material.color.set(0x00ff00);
                    stirrerButton.position.y = 1.15;
                    swirlParticles.visible = true;
                    bubbleTrail.visible = true;
                    meniscus.visible = false;
                } else {
                    stirrerButton.material.color.set(0xff0000);
                    stirrerButton.position.y = 1.25;
                    swirlParticles.visible = false;
                    bubbleTrail.visible = false;
                    meniscus.visible = true;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (stirrer && isStirring) stirrer.rotation.y += 0.1;
            
            const shader = liquidMaterial.userData.shader;
            if (shader) {
                const targetStrength = isStirring ? 1.0 : 0.0;
                shader.uniforms.u_strength.value = THREE.MathUtils.lerp(shader.uniforms.u_strength.value, targetStrength, 0.05);
                shader.uniforms.u_time.value += 0.05;
            }

            const strength = shader ? shader.uniforms.u_strength.value : 0;

            if (swirlParticles && swirlParticles.visible) {
                const positions = swirlParticles.geometry.attributes.position.array;
                const liquidHeight = 7.0;
                
                for (let i = 0; i < positions.length; i += 3) {
                    let x = positions[i], y = positions[i+1], z = positions[i+2];
                    let radius = Math.sqrt(x*x + z*z), angle = Math.atan2(z, x);
                    angle -= (1.0 / (radius + 0.5)) * 0.1 * strength;
                    y -= 0.02 * strength;
                    radius -= 0.01 * strength;
                    if (y < 0.3 || radius < 0.2) {
                        radius = Math.random() * 2 + 3.5;
                        angle = Math.random() * Math.PI * 2;
                        y = liquidHeight - Math.random() * 2;
                    }
                    positions[i] = radius * Math.cos(angle);
                    positions[i+1] = y;
                    positions[i+2] = radius * Math.sin(angle);
                }
                swirlParticles.geometry.attributes.position.needsUpdate = true;
            }

            if (bubbleTrail && bubbleTrail.visible) {
                const positions = bubbleTrail.geometry.attributes.position.array;
                const data = bubbleTrail.geometry.userData.data;
                const liquidHeight = 7.0;
                const startY = liquidHeight - (1.5 * strength); // Vortex tip

                for (let i = 0; i < data.length; i++) {
                    const i3 = i * 3;
                    data[i].life -= 0.01;

                    if (data[i].life <= 0) {
                        if (strength > 0.5 && Math.random() > 0.5) { // Respawn condition
                            positions[i3] = (Math.random() - 0.5) * 0.2 * strength;
                            positions[i3 + 1] = startY;
                            positions[i3 + 2] = (Math.random() - 0.5) * 0.2 * strength;
                            data[i].life = Math.random();
                            data[i].velocity.y = Math.random() * 0.05 + 0.02;
                        } else {
                             positions[i3 + 1] = -100; // Hide if not respawning
                        }
                    } else if (positions[i3 + 1] > 0) { // If alive and visible
                        positions[i3] += (Math.random() - 0.5) * 0.02;
                        positions[i3 + 1] -= data[i].velocity.y * strength;
                        positions[i3 + 2] += (Math.random() - 0.5) * 0.02;
                    }
                }
                bubbleTrail.geometry.attributes.position.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

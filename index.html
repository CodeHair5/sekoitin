<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Erlenmeyer-pullo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; cursor: pointer; }
        .info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            font-family: Arial, sans-serif;
            font-size: 16px;
            pointer-events: none;
            text-shadow: 0 0 5px white;
        }
    </style>
</head>
<body>
    <div class="info">Paina nappia käynnistääksesi sekoittajan. Vedä hiirellä pyörittääksesi.</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, flaskFront, flaskBack, liquid, meniscus, stirrer, swirlParticles, bubbleTrail;
        let stirrerPlate, stirrerButton;
        let isStirring = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let liquidMaterial; // To hold reference to the material with the shader

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 15, 5);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(0, 2, 0);
            scene.add(pointLight);

            // Create the objects
            createFlask();
            createLiquidAndEffects();
            createSwirlParticles();
            createBubbleTrail();
            createStirrer();
            createStirrerPlate();

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.target.set(0, 5, 0);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('pointerdown', onMouseClick, false);

            animate();
        }

        function createFlask() {
            const points = [];
            points.push(new THREE.Vector2(0, 0));
            points.push(new THREE.Vector2(6, 0));
            points.push(new THREE.Vector2(6, 0.5));
            points.push(new THREE.Vector2(2, 11.5));
            points.push(new THREE.Vector2(2, 15));
            points.push(new THREE.Vector2(2.5, 15.5));
            points.push(new THREE.Vector2(2.5, 16));
            points.push(new THREE.Vector2(2.2, 16));

            const geometry = new THREE.LatheGeometry(points, 32);
            
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xadd8e6,
                metalness: 0.1,
                roughness: 0.05,
                transmission: 1.0,
                thickness: 0.5,
                ior: 1.5,
                transparent: true,
                opacity: 0.3,
                envMapIntensity: 2,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            flaskFront = new THREE.Mesh(geometry, glassMaterial);
            flaskFront.renderOrder = 5; // FINAL RENDER ORDER
            scene.add(flaskFront);
        }
        
        function createLiquidAndEffects() {
            const liquidHeight = 7.0;
            const liquidRadiusAtTop = 3.4;
            const points = [];
            points.push(new THREE.Vector2(0, 0.2)); 
            points.push(new THREE.Vector2(5.8, 0.2));
            points.push(new THREE.Vector2(liquidRadiusAtTop, liquidHeight));
            points.push(new THREE.Vector2(0, liquidHeight));

            const geometry = new THREE.LatheGeometry(points, 64);

            liquidMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                transmission: 1.0,
                roughness: 0.1,
                metalness: 0.0,
                ior: 1.33,
                thickness: 1.0,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
                depthWrite: false,
                envMapIntensity: 2
            });
            
            liquidMaterial.onBeforeCompile = (shader) => {
                shader.uniforms.u_time = { value: 0 };
                shader.uniforms.u_strength = { value: 0 };

                shader.vertexShader = 'uniform float u_time;\n' + 'uniform float u_strength;\n' + shader.vertexShader;
                
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    `
                    #include <begin_vertex>
                    
                    if (position.y > ${liquidHeight - 0.01}) {
                        float dist = length(position.xz);
                        float depression = exp(-dist * 1.5) * 1.5 * u_strength;
                        transformed.y -= depression;
                        float wave = sin(dist * 3.0 - u_time * 5.0) * 0.1 * u_strength;
                        transformed.y += wave;
                    }
                    `
                );
                
                liquidMaterial.userData.shader = shader;
            };

            liquid = new THREE.Mesh(geometry, liquidMaterial);
            liquid.renderOrder = 1;
            scene.add(liquid);
            
            const meniscusGeometry = new THREE.TorusGeometry(liquidRadiusAtTop, 0.05, 16, 100);
            const meniscusMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.5,
                depthWrite: false,
                metalness: 0.0,
                roughness: 0.1,
                transmission: 0.5,
                ior: 1.33,
                envMapIntensity: 1
            });
            meniscus = new THREE.Mesh(meniscusGeometry, meniscusMaterial);
            meniscus.position.y = liquidHeight;
            meniscus.rotation.x = Math.PI / 2;
            meniscus.renderOrder = 4;
            scene.add(meniscus);
        }

        function createSwirlParticles() {
            const particleCount = 200;
            const positions = new Float32Array(particleCount * 3);
            const liquidHeight = 7.0;
            const minY = 0.3; // Ei pohjan läpi
            const maxY = 6.7; // Ei pinnan läpi
            // Pullon profiili: pohjalla leveä, ylhäällä kapeampi
            function swirlRadiusAtY(y) {
                // Suhteellinen korkeus 0...1
                const t = (y - minY) / (maxY - minY);
                // Pullon profiili: pohjalla leveä, ylhäällä kapeampi
                // Esim. lineaarinen kavennus 5.5 -> 2.2
                return 5.5 - 3.3 * t;
            }
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const y = minY + Math.random() * (maxY - minY);
                const maxR = swirlRadiusAtY(y);
                const radius = Math.random() * maxR;
                const angle = Math.random() * Math.PI * 2;
                positions[i3] = radius * Math.cos(angle);
                positions[i3 + 1] = y;
                positions[i3 + 2] = radius * Math.sin(angle);
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.07,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                depthWrite: false,
            });
            swirlParticles = new THREE.Points(geometry, material);
            swirlParticles.renderOrder = 2;
            swirlParticles.visible = false;
            scene.add(swirlParticles);
        }

        function createBubbleTrail() {
            const bubbleCount = 60;
            const bubbleTrailYStart = 1.2; // sekoittimen yläpuoli
            const bubbleTrailYEnd = 6.7; // nesteen pinta
            const bubbleTrailRadius = 0.5;
            const bubblePositions = new Float32Array(bubbleCount * 3);
            const bubbleData = [];
            for (let i = 0; i < bubbleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * bubbleTrailRadius;
                bubblePositions[i*3] = Math.cos(angle) * radius;
                bubblePositions[i*3+1] = bubbleTrailYStart;
                bubblePositions[i*3+2] = Math.sin(angle) * radius;
                bubbleData.push({
                    velocity: new THREE.Vector3(0, Math.random() * 0.03 + 0.01, 0),
                    life: Math.random()
                });
            }
            const bubbleGeometry = new THREE.BufferGeometry();
            bubbleGeometry.setAttribute('position', new THREE.BufferAttribute(bubblePositions, 3));
            bubbleGeometry.userData.data = bubbleData;
            const bubbleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.08,
                transparent: true,
                opacity: 0.8,
                blending: THREE.NormalBlending,
                depthWrite: false,
            });
            bubbleTrail = new THREE.Points(bubbleGeometry, bubbleMaterial);
            bubbleTrail.renderOrder = 3;
            bubbleTrail.visible = false;
            scene.add(bubbleTrail);
            // Tallenna parametrit globaaleiksi animointia varten
            bubbleTrail.userData.yStart = bubbleTrailYStart;
            bubbleTrail.userData.yEnd = bubbleTrailYEnd;
            bubbleTrail.userData.radius = bubbleTrailRadius;
        }

        function createStirrer() {
            const geometry = new THREE.CapsuleGeometry(0.3, 2.5, 4, 16);
            const material = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.1, metalness: 0.2 });
            stirrer = new THREE.Mesh(geometry, material);
            stirrer.rotation.z = Math.PI / 2;
            stirrer.position.y = 0.6;
            scene.add(stirrer);
        }

        function createStirrerPlate() {
            const plateGeometry = new THREE.BoxGeometry(15, 2, 15);
            const plateMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5, metalness: 0.1 });
            stirrerPlate = new THREE.Mesh(plateGeometry, plateMaterial);
            stirrerPlate.position.y = -1.1;
            scene.add(stirrerPlate);

            const buttonGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 32);
            const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            stirrerButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
            stirrerButton.position.set(5, 1.25, 5); 
            stirrerPlate.add(stirrerButton); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([stirrerButton]);
            if (intersects.length > 0) {
                isStirring = !isStirring;
                if (isStirring) {
                    stirrerButton.material.color.set(0x00ff00);
                    stirrerButton.position.y = 1.15;
                    swirlParticles.visible = true;
                    bubbleTrail.visible = true;
                    meniscus.visible = false;
                } else {
                    stirrerButton.material.color.set(0xff0000);
                    stirrerButton.position.y = 1.25;
                    swirlParticles.visible = false;
                    bubbleTrail.visible = false;
                    meniscus.visible = true;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (stirrer && isStirring) stirrer.rotation.y += 0.1;
            
            const shader = liquidMaterial.userData.shader;
            if (shader) {
                const targetStrength = isStirring ? 1.0 : 0.0;
                shader.uniforms.u_strength.value = THREE.MathUtils.lerp(shader.uniforms.u_strength.value, targetStrength, 0.05);
                shader.uniforms.u_time.value += 0.05;
            }

            const strength = shader ? shader.uniforms.u_strength.value : 0;

            if (swirlParticles && swirlParticles.visible) {
                const positions = swirlParticles.geometry.attributes.position.array;
                const liquidHeight = 7.0;
                const minY = 0.3;
                const maxY = 6.7;
                function swirlRadiusAtY(y) {
                    const t = (y - minY) / (maxY - minY);
                    return 5.5 - 3.3 * t;
                }
                for (let i = 0; i < positions.length; i += 3) {
                    let x = positions[i], y = positions[i+1], z = positions[i+2];
                    let radius = Math.sqrt(x*x + z*z), angle = Math.atan2(z, x);
                    angle -= (1.0 / (radius + 0.5)) * 0.1 * strength;
                    y -= 0.02 * strength;
                    // Kavennetaan sädettä ylöspäin mentäessä
                    let maxR = swirlRadiusAtY(y);
                    radius = Math.min(radius - 0.01 * strength, maxR);
                    if (y < minY || radius < 0.2) {
                        // Respawn partikkeli satunnaiseen korkeuteen ja sädelle
                        const newY = minY + Math.random() * (maxY - minY);
                        const newMaxR = swirlRadiusAtY(newY);
                        const newRadius = Math.random() * newMaxR;
                        const newAngle = Math.random() * Math.PI * 2;
                        positions[i] = newRadius * Math.cos(newAngle);
                        positions[i+1] = newY;
                        positions[i+2] = newRadius * Math.sin(newAngle);
                    } else {
                        positions[i] = radius * Math.cos(angle);
                        positions[i+1] = y;
                        positions[i+2] = radius * Math.sin(angle);
                    }
                }
                swirlParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animoidaan bubbleTrail-partikkelit nousemaan sekoittimen yläpuolelta nesteen pintaan
            if (bubbleTrail && bubbleTrail.visible) {
                const positions = bubbleTrail.geometry.attributes.position.array;
                const data = bubbleTrail.geometry.userData.data;
                const yStart = bubbleTrail.userData.yStart;
                const yEnd = bubbleTrail.userData.yEnd;
                const radiusMax = bubbleTrail.userData.radius;
                for (let i = 0; i < data.length; i++) {
                    const i3 = i * 3;
                    data[i].life -= 0.01;
                    if (data[i].life <= 0 || positions[i3+1] > yEnd) {
                        // Respawn kupla sekoittimen yläpuolelle
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * radiusMax;
                        positions[i3] = Math.cos(angle) * radius;
                        positions[i3+1] = yStart;
                        positions[i3+2] = Math.sin(angle) * radius;
                        data[i].velocity.y = Math.random() * 0.03 + 0.01;
                        data[i].life = 1.0 + Math.random();
                    } else {
                        positions[i3+1] += data[i].velocity.y;
                    }
                }
                bubbleTrail.geometry.attributes.position.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Korvattu vortexFragmentShader:
const vortexFragmentShader = `
    uniform float u_time;
    uniform float u_strength;
    varying float v_r;
    varying float v_theta;
    void main() {
        // Perusväri
        vec3 base = mix(vec3(0.53,0.8,1.0), vec3(1.0), 0.2 + 0.2 * v_r);
        // Kirkkaampi reunaväri
        float edge = smoothstep(0.85, 1.0, v_r);
        base = mix(base, vec3(1.0,1.0,1.0), edge * 0.7);
        // Emissiivinen efekti
        float emission = 0.15 + 0.25 * (1.0 - v_r);
        base += emission;
        float alpha = 0.7 * (1.0 - v_r) + 0.25 * edge;
        gl_FragColor = vec4(base, alpha * u_strength);
    }
`;

        init();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Erlenmeyer-pullo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; cursor: pointer; }
        .info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            font-family: Arial, sans-serif;
            font-size: 16px;
            pointer-events: none;
            text-shadow: 0 0 5px white;
        }
    </style>
</head>
<body>
    <div class="info">Paina nappia käynnistääksesi sekoittajan. Vedä hiirellä pyörittääksesi.</div>
    <button id="startBtn" style="position:absolute;left:50%;top:50px;transform:translateX(-50%);z-index:10;font-size:18px;padding:10px 30px;">Käynnistä simulaatio</button>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, flaskFront, flaskBack, liquid, meniscus, stirrer, swirlParticles, bubbleTrail;
        let stirrerPlate, stirrerButton;
        let isStirring = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let liquidMaterial; // To hold reference to the material with the shader

        let simulationStarted = false;
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startBtn').style.display = 'none';
            simulationStarted = true;
            init();
        });

        function init() {
            if (!simulationStarted) return;
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 15, 5);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(0, 2, 0);
            scene.add(pointLight);

            // Create the objects
            createFlask();
            createLiquidAndEffects();
            createSwirlParticles();
            createBubbleTrail();
            createStirrer();
            createStirrerPlate();

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.target.set(0, 5, 0);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('pointerdown', onMouseClick, false);

            animate();
        }

        function createFlask() {
            const points = [];
            points.push(new THREE.Vector2(0, 0));
            points.push(new THREE.Vector2(6, 0));
            points.push(new THREE.Vector2(6, 0.5));
            points.push(new THREE.Vector2(2, 11.5));
            points.push(new THREE.Vector2(2, 15));
            points.push(new THREE.Vector2(2.5, 15.5));
            points.push(new THREE.Vector2(2.5, 16));
            points.push(new THREE.Vector2(2.2, 16));

            const geometry = new THREE.LatheGeometry(points, 32);
            
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xadd8e6,
                metalness: 0.1,
                roughness: 0.05,
                transmission: 1.0,
                thickness: 0.5,
                ior: 1.5,
                transparent: true,
                opacity: 0.3,
                envMapIntensity: 2,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            flaskFront = new THREE.Mesh(geometry, glassMaterial);
            flaskFront.renderOrder = 5; // FINAL RENDER ORDER
            scene.add(flaskFront);
        }
        
        function createLiquidAndEffects() {
            const liquidHeight = 7.0;
            const liquidRadiusAtTop = 3.4;
            const points = [];
            points.push(new THREE.Vector2(0, 0.2)); 
            points.push(new THREE.Vector2(5.8, 0.2));
            points.push(new THREE.Vector2(liquidRadiusAtTop, liquidHeight));
            points.push(new THREE.Vector2(0, liquidHeight));

            const geometry = new THREE.LatheGeometry(points, 64);

            liquidMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                transmission: 1.0,
                roughness: 0.1,
                metalness: 0.0,
                ior: 1.33,
                thickness: 1.0,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
                depthWrite: false,
                envMapIntensity: 2
            });
            
            liquidMaterial.onBeforeCompile = (shader) => {
                shader.uniforms.u_time = { value: 0 };
                shader.uniforms.u_strength = { value: 0 };

                shader.vertexShader = 'uniform float u_time;\n' + 'uniform float u_strength;\n' + shader.vertexShader;
                
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    `
                    #include <begin_vertex>
                    
                    if (position.y > ${liquidHeight - 0.01}) {
                        float dist = length(position.xz);
                        float depression = exp(-dist * 1.5) * 1.5 * u_strength;
                        transformed.y -= depression;
                        float wave = sin(dist * 3.0 - u_time * 5.0) * 0.1 * u_strength;
                        transformed.y += wave;
                    }
                    `
                );
                
                liquidMaterial.userData.shader = shader;
            };

            liquid = new THREE.Mesh(geometry, liquidMaterial);
            liquid.renderOrder = 1;
            scene.add(liquid);
            
            const meniscusGeometry = new THREE.TorusGeometry(liquidRadiusAtTop, 0.05, 16, 100);
            const meniscusMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.5,
                depthWrite: false,
                metalness: 0.0,
                roughness: 0.1,
                transmission: 0.5,
                ior: 1.33,
                envMapIntensity: 1
            });
            meniscus = new THREE.Mesh(meniscusGeometry, meniscusMaterial);
            meniscus.position.y = liquidHeight;
            meniscus.rotation.x = Math.PI / 2;
            meniscus.renderOrder = 4;
            scene.add(meniscus);
        }

        function createSwirlParticles() {
            // GPU-pohjainen swirl: käytetään ShaderMaterialia ja siemeniä
            const particleCount = 400;
            const geometry = new THREE.BufferGeometry();
            const seeds = new Float32Array(particleCount * 4);
            const positions = new Float32Array(particleCount * 3); // Dummy, vaaditaan Three.js:lle
            const minY = 0.3, maxY = 6.7;
            for (let i = 0; i < particleCount; i++) {
                seeds[i*4+0] = Math.random(); // korkeus 0..1
                seeds[i*4+1] = Math.random(); // kulma 0..1
                seeds[i*4+2] = Math.random(); // säde 0..1
                seeds[i*4+3] = Math.random(); // offset
                positions[i*3+0] = 0;
                positions[i*3+1] = 0;
                positions[i*3+2] = 0;
            }
            geometry.setAttribute('seed', new THREE.BufferAttribute(seeds, 4));
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); // Pakollinen attribuutti
            const swirlVertexShader = `
                attribute vec4 seed;
                uniform float u_time;
                uniform float u_strength;
                varying float v_r;
                void main() {
                    float minY = ${minY.toFixed(2)};
                    float maxY = ${maxY.toFixed(2)};
                    float t = seed.x;
                    float y = minY + t * (maxY - minY);
                    float swirlR = 9.5 - 3.3 * t;
                    float r = swirlR * pow(seed.z, 1.0);
                    float angle = seed.y * 6.2831853 + u_time * 0.7 * u_strength + seed.w * 6.2831853;
                    // Swirl-efekti
                    angle -= (1.0 / (r + 0.5)) * 0.7 * u_strength * u_time;
                    y -= 0.5 * u_strength * u_time * 0.03;
                    if (y < minY) {
                        y = maxY - mod(u_time * 0.03 + seed.w, 1.0) * (maxY-minY);
                        r = swirlR * pow(fract(seed.z + u_time * 0.1), 1.0);
                    }
                    v_r = r / swirlR;
                    vec3 pos = vec3(r * cos(angle), y, r * sin(angle));
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = 3.5;
                }
            `;
            const swirlFragmentShader = `
                varying float v_r;
                void main() {
                    float d = length(gl_PointCoord - vec2(0.5));
                    if (d > 0.5) discard;
                    vec3 col = mix(vec3(1.0,1.0,1.0), vec3(0.5,0.8,1.0), v_r);
                    float alpha = 0.7 * (1.0-v_r) * (1.0-d*2.0);
                    gl_FragColor = vec4(col, alpha);
                }
            `;
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    u_time: { value: 0 },
                    u_strength: { value: 0 }
                },
                vertexShader: swirlVertexShader,
                fragmentShader: swirlFragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            swirlParticles = new THREE.Points(geometry, material);
            swirlParticles.renderOrder = 2;
            swirlParticles.visible = false;
            scene.add(swirlParticles);
        }

        function createBubbleTrail() {
            const bubbleCount = 60;
            const bubbleTrailYStart = 1.2; // sekoittimen yläpuoli
            const bubbleTrailYEnd = 6.7; // nesteen pinta
            const bubbleTrailRadius = 0.5;
            const bubblePositions = new Float32Array(bubbleCount * 3);
            const bubbleData = [];
            for (let i = 0; i < bubbleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * bubbleTrailRadius;
                bubblePositions[i*3] = Math.cos(angle) * radius;
                bubblePositions[i*3+1] = bubbleTrailYStart;
                bubblePositions[i*3+2] = Math.sin(angle) * radius;
                bubbleData.push({
                    velocity: new THREE.Vector3(0, Math.random() * 0.03 + 0.01, 0),
                    life: Math.random()
                });
            }
            const bubbleGeometry = new THREE.BufferGeometry();
            bubbleGeometry.setAttribute('position', new THREE.BufferAttribute(bubblePositions, 3));
            bubbleGeometry.userData.data = bubbleData;
            // Luo pyöreä tekstuuri canvasilla
            function createCircleTexture(size = 64) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,size,size);
                ctx.beginPath();
                ctx.arc(size/2, size/2, size/2-2, 0, 2*Math.PI);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.shadowColor = 'white';
                ctx.shadowBlur = size/4;
                ctx.fill();
                return new THREE.CanvasTexture(canvas);
            }
            const bubbleTexture = createCircleTexture(64);
            const bubbleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.08,
                transparent: true,
                opacity: 0.8,
                blending: THREE.NormalBlending,
                depthWrite: false,
                map: bubbleTexture,
                alphaTest: 0.1
            });
            bubbleMaterial.needsUpdate = true;
            bubbleTrail = new THREE.Points(bubbleGeometry, bubbleMaterial);
            bubbleTrail.renderOrder = 3;
            bubbleTrail.visible = false;
            scene.add(bubbleTrail);
            // Tallenna parametrit globaaleiksi animointia varten
            bubbleTrail.userData.yStart = bubbleTrailYStart;
            bubbleTrail.userData.yEnd = bubbleTrailYEnd;
            bubbleTrail.userData.radius = bubbleTrailRadius;
        }

        function createStirrer() {
            const geometry = new THREE.CapsuleGeometry(0.3, 2.5, 4, 16);
            const material = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.1, metalness: 0.2 });
            stirrer = new THREE.Mesh(geometry, material);
            stirrer.rotation.z = Math.PI / 2;
            stirrer.position.y = 0.6;
            scene.add(stirrer);
        }

        function createStirrerPlate() {
            const plateGeometry = new THREE.BoxGeometry(15, 2, 15);
            const plateMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5, metalness: 0.1 });
            stirrerPlate = new THREE.Mesh(plateGeometry, plateMaterial);
            stirrerPlate.position.y = -1.1;
            scene.add(stirrerPlate);

            const buttonGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 32);
            const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            stirrerButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
            stirrerButton.position.set(5, 1.25, 5); 
            stirrerPlate.add(stirrerButton); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([stirrerButton]);
            if (intersects.length > 0) {
                isStirring = !isStirring;
                if (isStirring) {
                    stirrerButton.material.color.set(0x00ff00);
                    stirrerButton.position.y = 1.15;
                    swirlParticles.visible = true;
                    bubbleTrail.visible = true;
                    meniscus.visible = false;
                } else {
                    stirrerButton.material.color.set(0xff0000);
                    stirrerButton.position.y = 1.25;
                    swirlParticles.visible = false;
                    bubbleTrail.visible = false;
                    meniscus.visible = true;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (stirrer && isStirring) stirrer.rotation.y += 0.2;
            
            const shader = liquidMaterial.userData.shader;
            if (shader) {
                const targetStrength = isStirring ? 1.0 : 0.0;
                shader.uniforms.u_strength.value = THREE.MathUtils.lerp(shader.uniforms.u_strength.value, targetStrength, 0.05);
                shader.uniforms.u_time.value += 0.05;
            }

            const strength = shader ? shader.uniforms.u_strength.value : 0;

            // Animoidaan swirlParticles GPU:ssa
            if (swirlParticles && swirlParticles.visible) {
                swirlParticles.material.uniforms.u_time.value += 0.05;
                swirlParticles.material.uniforms.u_strength.value = isStirring ? 1.0 : 0.0;
            }

            // Animoidaan bubbleTrail-partikkelit nousemaan sekoittimen yläpuolelta nesteen pintaan
            if (bubbleTrail && bubbleTrail.visible) {
                const positions = bubbleTrail.geometry.attributes.position.array;
                const data = bubbleTrail.geometry.userData.data;
                const yStart = bubbleTrail.userData.yStart;
                const yEnd = bubbleTrail.userData.yEnd;
                const radiusMax = bubbleTrail.userData.radius;
                for (let i = 0; i < data.length; i++) {
                    const i3 = i * 3;
                    data[i].life -= 0.01;
                    if (data[i].life <= 0 || positions[i3+1] > yEnd) {
                        // Respawn kupla sekoittimen yläpuolelle
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * radiusMax;
                        positions[i3] = Math.cos(angle) * radius;
                        positions[i3+1] = yStart;
                        positions[i3+2] = Math.sin(angle) * radius;
                        data[i].velocity.y = Math.random() * 0.03 + 0.01;
                        data[i].life = 1.0 + Math.random();
                    } else {
                        positions[i3+1] += data[i].velocity.y;
                    }
                }
                bubbleTrail.geometry.attributes.position.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Korvattu vortexFragmentShader:
const vortexFragmentShader = `
    uniform float u_time;
    uniform float u_strength;
    varying float v_r;
    varying float v_theta;
    void main() {
        // Perusväri
        vec3 base = mix(vec3(0.53,0.8,1.0), vec3(1.0), 0.2 + 0.2 * v_r);
        // Kirkkaampi reunaväri
        float edge = smoothstep(0.85, 1.0, v_r);
        base = mix(base, vec3(1.0,1.0,1.0), edge * 0.7);
        // Emissiivinen efekti
        float emission = 0.15 + 0.25 * (1.0 - v_r);
        base += emission;
        float alpha = 0.7 * (1.0 - v_r) + 0.25 * edge;
        gl_FragColor = vec4(base, alpha * u_strength);
    }
`;

        init();
    </script>
</body>
</html>
